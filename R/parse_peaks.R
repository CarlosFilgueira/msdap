#' Import a label-free proteomics dataset from Peaks
#'
#' @param filename a features.csv file exported by Peaks
#' @param collapse_peptide_by if multiple data points are available for a peptide in a sample, at what level should these be combined? options: "sequence_modified" (recommended default), "sequence_plain", ""
#'
#' @importFrom data.table fread
#' @importFrom tidyr pivot_longer
#' @export
import_dataset_peaks = function(filename, collapse_peptide_by = "sequence_modified") {
  append_log("reading features.csv generated by Peaks", type = "info")

  if(!(collapse_peptide_by %in% c("sequence_plain", "sequence_modified", ""))) {
    append_log('collapse_peptide_by parameter must be any of; "sequence_plain", "sequence_modified", ""', type = "error")
  }

  # first, check if input file exists
  check_parameter_is_string(filename)
  if (!file.exists(filename)) {
    append_log(paste("input file does not exist:", filename), type = "error")
  }


  regex_rt = "[ .]rt[ .]mean$"
  regex_intensity = "[ .](normalized[ .]){0,1}area$"

  headers = tolower(unlist(strsplit(readLines(filename, n = 1), "\t|,")))

  # validate the input is peaks (recycle generic function which includes robust matching and error messages)
  attributes_required = list(sequence_modified = "Peptide",
                             protein_id = "Accession",
                             charge = "z")
  map_required = map_headers(headers, attributes_required, error_on_missing = T, allow_multiple = T)

  # guestimate the sample names from column headers
  map_sample_rt = grep(regex_rt, headers, ignore.case = T)
  sample_id = gsub(regex_rt, "", headers[map_sample_rt])
  cols_int = which(gsub(regex_intensity, "", headers) %in% sample_id)

  # input validation
  if(length(sample_id) != length(cols_int) || length(cols_int) != length(map_sample_rt)) {
    append_log(sprintf("cannot locate a column for both RT and intensity for all samples! RT columns: [%s]   intensity columns: [%s]",
                       paste(headers[map_sample_rt], collapse = ", "), paste(headers[cols_int], collapse = ", ")), type = "error")
  }

  # only read columns of interest to speed up file parsing
  tibw = as_tibble(data.table::fread(filename, select = c(as.numeric(map_required), map_sample_rt, cols_int), check.names = F, stringsAsFactors = F))
  colnames(tibw)[seq_along(map_required)] = names(map_required)

  # filter invalid entries; empty value in any column-of-interest
  tibw = tibw %>%
    filter_if(is.numeric, all_vars(is.finite(.) & . > 0)) %>%
    filter_if(is.character, all_vars(. != ""))


  ### convert from wide-to-long format
  # peptide description
  tibw$sequence_plain = gsub("(\\[[^]]*\\])|(\\([^)]*\\))", "", tibw$sequence_modified)
  tibw$peptide_id = paste0(tibw$sequence_modified, "_", tibw$charge)

  ## rename RT and intensity columns
  # first, replace illegal characters; replace all # with _
  colnames(tibw) = gsub("#+", "_", colnames(tibw))
  # slightly over-complicated regex to account for scenarios where sample names contain multiple spaces (bad practice, but users could name stuff; sample cond1 rep2)
  colnames(tibw) = gsub(paste0("^ *(\\S.*\\S) *", regex_rt), "rt###\\1", colnames(tibw), ignore.case = T)
  colnames(tibw) = gsub(paste0("^ *(\\S.*\\S) *", regex_intensity), "intensity###\\1", colnames(tibw), ignore.case = T)
  tib = pivot_longer(tibw,
                     cols = -c("peptide_id", "sequence_plain", names(map_required)),
                     names_to = c(".value", "sample_id"),
                     names_sep = "###")


  # compatability with downstream pipeline (standard in every import function)
  tib$confidence = NA
  tib$detect = T
  tib$intensity = log2(tib$intensity)
  tib$isdecoy = F

  # collapse peptides by plain or modified sequence (eg; peptide can be observed in some sample with and without modifications, at multiple charges, etc)
  if(collapse_peptide_by == "") {
    # if 'no collapse' is set, at least merge by modseq and charge. eg; there may be multiple peaks for some peptide with the same charge throughout retention time
    tib = peptides_collapse_by_sequence(tib, prop_peptide = "peptide_id")
    append_log("NOT collapsing peptides by plain/modified-sequence, thus 2 observations of the same sequence with different charge are considered a distinct peptide_id. This is not recommended for DDA!", type = "warning")
  } else {
    tib = peptides_collapse_by_sequence(tib, prop_peptide = collapse_peptide_by) # alternative, collapse modified sequences; prop_peptide = "sequence_modified"
  }

  log_peptide_tibble_pep_prot_counts(tib)
  return(list(peptides=tibble_peptides_reorder(tib), proteins=empty_protein_tibble(tib), acquisition_mode = "dda"))
}
